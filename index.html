<!DOCTYPE html>
<html>
<head>
    <title>Tendances des mots-clefs</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
    
</head>
<body>
    <h1>Tendances des mots-clefs</h1>
    <table>
        <tr>
            <td id="colGrid"></td>
            <td id="colMap"></td>
        </tr>
    </table>
</body>
</html>

<script>
    // Set up the dimensions of the map
    let width = 800, height = 600, noColor="#4682b469",

    // Create an SVG element
    svg = d3.select("#colMap")
        .append("svg")
        .attr("width", width)
        .attr("height", height),

    // Create a projection for Europe
    projection = d3.geoMercator()
        .center([10, 50])
        .scale(600)
        .translate([width / 2, height / 2]),
    // Create a path generator
    path = d3.geoPath()
        .projection(projection),
    dataPays, dataKW=[], dataMotclefs, dataGeo, 
    arrAdsFiles = [
        {'pays':'France','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_07_29-france.csv'},
        {'pays':'Pologne','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_11_13-pologne.csv'},
        {'pays':'Allemagne','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_09_31-Allemagne.csv'},
        {'pays':'Italie','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_09_59-italie.csv'},
        {'pays':'Espagne','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_10_51-espagne.csv'},
        {'pays':'Royaume-Uni','path':'assets/data/ads/Keyword Stats 2024-08-08 at 08_10_24-royaumeuni.csv'}
    ], arrPromise = arrAdsFiles.map(f=>d3.csv(f.path));    
    arrPromise.push(d3.csv("assets/data/Motsclefs.csv"));
    arrPromise.push(d3.json("assets/data/europe.geojson"));
    arrPromise.push(d3.json("assets/data/countries-FR.json"));
        
    // Load the JSON files
    Promise.all(arrPromise).then(function(files) {
        dataMotclefs = files[arrAdsFiles.length];
        dataGeo = files[arrAdsFiles.length+1];
        dataPays = files[arrAdsFiles.length+2];
        // Access the loaded data
        arrAdsFiles.forEach((af,i)=>{
            files[i].forEach(df=>{
                df.Pays=af.pays;
                let mc = dataMotclefs.filter(m=>m.Keyword==df.Keyword);
                df.Domaine=mc.length ? mc[0].Domaine : "aucun";
                df.langue=mc.length ? mc[0].langue : "aucun"
                dataKW.push(df);
            })
        })        
        
        // Group the data by keyword
        var groupKeyword = d3.group(dataKW, d => d.Keyword),
            groupPays = d3.group(dataKW, d => d.Pays);
            
        // Group the data by keyword and calculate the sum of monthly searches
        var groupPaysSum = d3.rollups(dataKW, v => d3.sum(v, d => d["Avg. monthly searches"]), d => d.Pays);

        // Calculate the extent of the sum of monthly searches
        var extent = d3.extent(groupPaysSum,d=>d[1]);

        // Create a color scale
        var colorScale = d3.scaleSequential()
            .domain(extent) // Set the domain of the scale
            .interpolator(d3.interpolateReds); // Set the color interpolator
        // Create a color axis

        let cols =  [
                    'Domaine',
                    'Keyword',
                    'Langue',
                    'Pays',
                    'Avg. monthly searches',
                    'Competition'
                ],
        container = document.createElement("div");
        document.getElementById('colGrid').appendChild(container);
        var hot = new Handsontable(container, {
            data: dataKW,
            width: (width+100)+'px',
            height: height+'px',
            rowHeaders: true,
            colHeaders: cols,
            columns: [
                { data: "Domaine", type: "text" },
                { data: "Keyword", type: "text" },
                { data: "langue", type: "text" },
                { data: "Pays", type: "text" },
                { data: "Avg. monthly searches", type: "numeric" },
                { data: "Competition", type: "text" },                
            ],
            licenseKey: 'non-commercial-and-evaluation',
            filters: true,
            dropdownMenu: true,
            multiColumnSorting: true,
        });
        hot.addHook('afterSelectionEnd', (row, col, row2, col2) => {
            // Get the selected range
            var selectedRange = hot.getSelectedRange();
            if (selectedRange.length) {
                selectedRange = selectedRange[0];
                // Get the start and end coordinates of the range
                let startRow = selectedRange.from.row,
                    startCol = selectedRange.from.col,
                    endRow = selectedRange.to.row,
                    endCol = selectedRange.to.col,
                    sltData=[], sltDataRow={};

                // Perform operations on the selected range            
                for (var row = startRow; row <= endRow; row++) {
                    sltDataRow={};
                    //on boucle sur toute les colonnes
                    cols.forEach((c,i)=>{
                        sltDataRow[c]=hot.getDataAtCell(row, i);
                    })
                    if(sltDataRow.Pays)sltData.push(sltDataRow);
                }
                updateMapColor(sltData); 
            }
        });

        // Convert the TopoJSON data to GeoJSON
        //var europe = topojson.feature(dataGeo, dataGeo.objects.countries);
        var europe = dataGeo;
        
        // Draw the map
        svg.selectAll("path")
            .data(europe.features)
            .enter()
            .append("path")
            .attr("class", "pPays")
            .attr("d", path)
            .style("fill", function (d) {
                // Replace this with your own data and color scale
                let pays = groupPaysSum.filter(p=>p[0]==dataPays[d.properties.ISO2]),
                color = pays.length ? colorScale(pays[0][1]) : noColor;
                return color;
            });

        addColorLegend(colorScale)            

    }).catch(function(error) {
        console.log("Error loading JSON files:", error);
    });

    function updateMapColor(data) {
        // Group the data by keyword and calculate the sum of monthly searches
        var groupPaysSum = d3.rollups(data, v => d3.sum(v, d => d["Avg. monthly searches"]), d => d.Pays);

        // Calculate the extent of the sum of monthly searches
        var extent = d3.extent(groupPaysSum,d=>d[1]);

        // Create a color scale
        var colorScale = d3.scaleSequential()
            .domain(extent) // Set the domain of the scale
            .interpolator(d3.interpolateReds); // Set the color interpolator

        svg.selectAll(".pPays").style("fill",(d,i)=>{
            // Replace this with your own data and color scale
            let pays = groupPaysSum.filter(p=>p[0]==dataPays[d.properties.ISO2]),
            color = pays.length ? colorScale(pays[0][1]) : "steelblue";
            return color;
        });

        addColorLegend(colorScale)
    }



    function addColorLegend(scaleColor) {
        svg.select('#gColorlegend').remove();
        let legendCellSize = 20, nbRect=20 
            legend = svg.append('g').attr('id','gColorlegend')
                .attr('transform', 'translate(0, '+(height-legendCellSize)+')'),
            domainColor = scaleColor.domain(),
            dataLegend = d3.range(domainColor[0],domainColor[1],(domainColor[1]-domainColor[0])/nbRect),
            scaleLegend= d3.scaleBand(dataLegend, [0, width]).paddingInner(0);
            
        legend.selectAll('rect')
            .data(dataLegend)
            .enter().append('rect')
                .attr('height', legendCellSize + 'px')
                .attr('width', scaleLegend.bandwidth() + 'px')
                .attr('y', 0)
                .attr('x', d => {
                    return scaleLegend(d);
                })
                .attr('class', 'legend-cell')
                .style("fill", d => scaleColor(d))
                /*
                .on("mouseover", function(event, d) {
                    legend.select("#cursor")
                        .attr('transform', 'translate(' + (legendCellSize + 5) + ', ' + (d * legendCellSize) + ')')
                        .style("display", null);
                    d3.selectAll("path[scorecolor='" + colors[d] + "']")
                        .style('fill', "#F1F501");
                })
                .on("mouseout", function(event, d) {
                    legend.select("#cursor")
                        .style("display", "none");
                    d3.selectAll("path[scorecolor='" + colors[d] + "']")
                        .style('fill', colors[d]);
                })
                */;
        
        legendAxis = legend.append("g")
            .attr("class", "axis")
            .call(d3.axisTop(scaleLegend).ticks(10).tickFormat(d3.format(".2s")));
        
        return legend;
    }    

</script>
